<script src="tinytest.js"></script>
<script>

  function reduce(array, callback, initialValue) {

    var startingIndex = 0;
    var resultSoFar = initialValue;

    //detect if no initial value
    if (arguments.length < 3) {
      //if array has one element just return it.
      if (Object.keys(array).length === 1) {
        var onlyIndex = Object.keys(array)[0];
        var onlyElement = array[onlyIndex]
        return onlyElement;
      }

      //skip holes at the beginning of the array
      while (startingIndex in array === false) {
        startingIndex++;
      }

      resultSoFar = array[startingIndex];
      startingIndex++;

    } else { //has initialValue
      if (Object.keys(array).length === 0) {
        return initialValue;
      }
    }

    for (var i = startingIndex; i < array.length; i++) {
      if (i in array) {
        resultSoFar = callback(resultSoFar, array[i], i);
      }
    }
    return resultSoFar;
  }

  tests({
    //------------------------------------------------------------------------------
    'if (initialValue), callback should run array.length times': function () {
      var numberOfTimesCallbackHasRun = 0;
      reduce([1, 2, 3], function () {
        numberOfTimesCallbackHasRun++
      }, 0)
      eq(numberOfTimesCallbackHasRun, 3)
    },
    'if (!initialValue), callback should run array.length -1  times': function () {
      var numberOfTimesCallbackHasRun = 0;
      reduce([1, 2, 3], function () {
        numberOfTimesCallbackHasRun++
      })
      eq(numberOfTimesCallbackHasRun, 2)
    },

    'if (intialValue) --- previousValue should start with  intialvalue': function () {
      reduce([1], function (previousValue) {
        eq(previousValue, 0);
      }, 0)
    },
    'if (initialValue) --- currentValue should start with array[0]': function () {
      reduce([1], function (previousValue, currentValue) {
        eq(currentValue, 1);
      }, 0)
    },
    'if (intialValue)  --- calballback will start at index 0': function () {
      reduce([1], function (previousValue, currentValue, currentIndex) {
        eq(currentIndex, 0);
      }, 0)
    },
    //------------------------------------------------------------------------------- 
    'if (!intialValue)  --- previousValue should start with  array[0]': function () {
      reduce([1, 2], function (previousValue) {
        eq(previousValue, 1);
      });
    },
    'if (!intialValue)  --- currentValue should start with array[1]': function () {
      reduce([1, 2], function (previousValue, currentValue) {
        eq(currentValue, 2);
      });
    },
    'if (!intialValue)  --- callback will start at index 1': function () {
      reduce([1, 2], function (previousValue, currentValue, currentIndex) {
        eq(currentIndex, 1);
      });
    },

    'if (initialValue) and array is empty, return intialValue without calling callback': function () {
      var numberOfTimesCallbackHasRun = 0
      var initialValue = 0;
      var reduceResult = reduce([, ,], function () {
        numberOfTimesCallbackHasRun++;
      }, 0);
      eq(reduceResult, initialValue)
      eq(numberOfTimesCallbackHasRun, 0)
    },
    'if (!initialValue) and array has one element, return element without calling callback': function () {
      var numberOfTimesCallbackHasRun = 0;

      var reduceResult = reduce([1], function () {
        numberOfTimesCallbackHasRun++;
      });
      eq(reduceResult, 1)
      eq(numberOfTimesCallbackHasRun, 0)
    },
    //----------------------------------------------------------------------------------- 
    'it should actually reduce': function () {
      var sum = reduce([1, 2, 3], function (a, b) {
        return a + b;
      }, 0);

      eq(sum, 6)
    },
    'if (intialValue) it should exclude holes': function () {
      var sum = reduce([, 1, , 2, , 3,], function (a, b) {
        return a + b;
      }, 0);

      eq(sum, 6)
    },
    'if (!intialValue) it should exclude holes too (!': function () {
      var sum = reduce([, 1, , 2, 3,], function (a, b) {
        return a + b;
      });
      eq(sum, 6);
    },


    'if array is empty and (!intialValue) --- TypeError should be thrown': function () {
      var isTypeError = false;
      try {
        reduce([], function () { });
      } catch (e) {
       var isTypeError = (e instanceof TypeError);
      }
      eq(isTypeError, true);
    },
    'it should pass in array as fourth arguement to callback': function () {
      fail()
    }

  });
  //PROTOTYPE IMPLEMENTATION
  //  function reduce(array, callback, initialValue){
  //       var previousValue = initialValue;
  //       for (var i = 0; i < array.length; i++){
  //           previousValue = callback(previousValue, array[i], i, array)
  //       }
  //       return previousValue;
  //       }

//FUNCTION SIGNATURE
//reduce(array, callback[, initialValue])

//CALLBACK PARAMETERS 
  // previous value = the running total
  // current value = array[i]
  // current index = i
  // array = array

  //RETURN VALUE
  //returns a single value


</script>